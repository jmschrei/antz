import numpy as np

class Population( object ):
	'''
	This represents a single population for a single allele. The population is
	represented as a generator, spitting out statistics about the population at
	each generation. Determistic models are implemented according to 
	Fundamentals of Molecular Evolution by Dan Graur and Wen-Hsiung Li, p41-47.
	'''

	models = { 
		'fitness': lambda p, q, w11, w12, w22: 
									p*q*( p*( w12-w11 ) + q*( w22-w12 ) ) / 
									( w11*p**2. + 2.*p*q*w12 + w22*q**2. ),
		'codominance': lambda p, q, s:
									s*p*q / ( 1. + 2.*s*p*q + 2.*s*q**2. ),
		'dominance': lambda p, q, s:
									s*q*p**2. / ( 1.-s-s*p**2. ),
		'recessive': lambda p, q, s:
									s*p*q**2. / ( 1. + s*q**2. ),
		'overdominance': lambda p, q, s, t:
									p*q*( 2.*s*q - t*q - s ) / 
									( 1. + 2.*s*q*p + t*q**2. ),
		'stochastic': lambda n, p, q: np.sum( np.where( np.random.random_sample(2*n) >= p, 1., 0.) ) / (2*n) - q
		}

	def __init__( self, n, p, q, model='dominance', **kwargs ):
		'''
		Take in a population size, and initial percentages of alleles p and q.
		Q is considered to be the allele of interest, meaning that a dominant
		model will consider Q dominant, and a recessive model will consider
		Q recessive. Models must be one of the ones indicated above, and the
		appropriate parameter must be passed in as well.
		'''

		self.n, self.p, self.q, self.model = n, p, q, model
		for key, value in kwargs.iteritems():
			setattr( self, key, value )
		self.params = { 'fitness': [ 'p', 'q', 'w11', 'w12', 'w22' ],
						'codominance': [ 'p', 'q', 's' ],
						'dominance': [ 'p', 'q', 's' ],
						'recessive': [ 'p', 'q', 's' ],
						'overdominance': [ 'p', 'q', 's', 't' ],
						'stochastic': [ 'n', 'p', 'q' ]
					  }.get( model, [] )
		self.Q = [ q ]
		self.fixed = False
		self.fixation_time = None

	def __iter__( self ):
		return self

	def next( self ):
		if self.q == 0.0 or self.q == 1.0:
			self.fixed = True
			self.fixation_time = self.fixation_time or len(self.Q)
		else:
			params = [ getattr( self, param ) for param in self.params ]
			dQ = Population.models[self.model]( *params )

			self.q += dQ
			self.p -= dQ
			self.Q.append( self.q )

	def fixate( self, i=None ):
		while self.fixed == False and i > 0:
			print i
			next( self )
			if i:
				i -= 1
		return self

	def plot( self, **kwargs ):
		print __name__
		plt.plot( xrange( len( self.Q ) ), self.Q, **kwargs )

class Simulation( object ):
	'''
	This is for use in population simulations, using many populations to show
	a random phenomena. 
	'''
	
	def __init__( self, N=100, model='stochastic', n=100, p=0.5, q=0.5, **kwargs ):
		assert model in Population.models and N > 0
		assert p + q == 1.0 and p >= 0 and q >= 0
		self.N, self.n, self.p, self.q = N, n, p, q
		self.pops = [ Population( n, p, q, model, **kwargs ) for i in xrange( N )]
		self.model = model
		for key, value in kwargs.iteritems():
			setattr( self, key, value )

	def __iter__( self ):
		return self

	def next( self ):
		map( next, self.pops )

	def fixate( self, summary_index=None, verbose=False ):
		'''
		Run the simulation until fixation is achieved on all populations. Returns a summary of the
		state of the simulation every summary_index generations if requested. Can return the
		number of populations which have fixated if verbose is passed in as true.
		'''
		self.i, fixated = 0, 0
		while fixated != self.N:
			next( self )

			fixated = np.sum( pop.fixed for pop in self.pops )
			self.i += 1
			if verbose:
				print "Iteration {}: {} fixated out of {} populations.".format( self.i, fixated, self.N )
			if summary_index and self.i % summary_index == 0 and self.i > 0:
				self.summary()

	def plot( self, **kwargs ):
		'''
		Return a plot of the frequency of Q for each population, for each generation. Each
		population is colored according to a simple color cycle. 
		'''
		durations = [ len(pop.Q) for pop in self.pops ]

		plt.figure( facecolor='w' )
		ax = plt.subplot( 111, axisbg='0.85' )
		ax.set_axisbelow(True)
		plt.grid( True, linewidth=2.0, color='0.925', linestyle='-' )
		plt.title( "{N} Populations with q = {q} and n = {n} ".format( N=self.N, q=self.q, n=self.n ), fontsize=18 )
		plt.ylabel( "Frequency", fontsize=14 )
		plt.xlabel( "Generation", fontsize=14 )
		for pop in self.pops:
			plt.plot( pop.Q, **kwargs )
		plt.show()

	def summary( self ):
		'''
		Providies a summary on the current state of the simulation. Returns the generations,
		number of populations in which state, and various statistics about the populations
		which have fixated. 
		'''

		fixated = np.sum( pop.q == 1.0 for pop in self.pops )
		lost = np.sum( pop.q == 0.0 for pop in self.pops )
		meandering = self.N - fixated - lost

		fixation_times = [ pop.fixation_time for pop in self.pops if pop.fixed ]
		n = len(fixation_times)
		avg_fixation_time = np.mean( fixation_times ) if n > 0 else -1.
		median_fixation_time = np.median( fixation_times ) if n > 0 else -1.
		std_fixation_time = np.std( fixation_times ) if n > 0 else -1.
		min_fixation_time = np.min( fixation_times ) if n > 0 else -1 
		max_fixation_time = np.max( fixation_times ) if n > 0 else -1

		print
		print "-- Simulation Parameters --"
		print "{:11}: {:6}".format( "Generations", self.i )
		print "{:11}: {:6}   %{:6}".format( "Fixated", fixated, 100.*fixated/self.N )
		print "{:11}: {:6}   %{:6}".format( "Lost", lost, 100.*lost/self.N )
		print "{:11}: {:6}   %{:6}".format( "Meandering", meandering, 100.*meandering/self.N )
		print "-- Fixation Time Statistics --"
		print "{:7}: {:8.4}".format( "Average", avg_fixation_time )
		print "{:7}: {:8.4}".format( "Median", median_fixation_time )
		print "{:7}: {:8.4}".format( "STD", std_fixation_time )
		print "{:7}: {:8}".format( "Min", min_fixation_time )
		print "{:7}: {:8}".format( "Max", max_fixation_time )
		print


import matplotlib.pyplot as plt


N, n, p, q = 100, 100, 0.9, 0.1
a = Population( n=n, p=p, q=q, s=0.2, t=0.3, model='dominance' ).fixate( i = 1000 )
a.plot( linewidth=5, c='k' )

sim = Simulation( N=N, n=n, p=p, q=q, model='stochastic' )
sim.fixate( 10 )
sim.summary()
#sim.plot( linewidth=1.5, alpha=0.66 )
plt.show()
